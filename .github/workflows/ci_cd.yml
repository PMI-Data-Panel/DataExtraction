# ============================================================================
# CI/CD Pipeline 설명
# ============================================================================
# 
# 이 파이프라인은 다음과 같은 단계로 구성됩니다:
#
# 1. TEST 단계 (코드 품질 및 테스트)
#    - 코드 체크아웃
#    - Python 환경 설정
#    - 의존성 설치
#    - Linter 실행 (flake8)
#    - 코드 포맷팅 확인 (black)
#    - 테스트 실행 (pytest)
#
# 2. BUILD 단계 (Docker 이미지 빌드)
#    - .env 파일 생성: GitHub Secrets의 ENV_FILE에서 전체 .env 내용 가져오기
#    - Docker Buildx 설정
#    - GitHub Container Registry 로그인
#    - Docker 이미지 빌드 및 푸시
#    - Docker 이미지 테스트 (헬스 체크)
#
# 3. DEPLOY 단계 (SSH를 통한 프로덕션 배포)
#    - SSH 키 설정 (SSH_PRIVATE_KEY secret 사용)
#    - 서버 접속 정보 설정 (SSH_HOST secret 사용)
#    - .env 파일 생성 및 서버로 전송 (ENV_FILE secret 사용)
#    - Docker 이미지 pull 또는 로컬 빌드
#    - Docker Compose로 서비스 시작
#    - 헬스 체크 확인
#
# ============================================================================
# GitHub Secrets 설정
# ============================================================================
#
# 필수 Secrets:
#   - ENV_FILE: .env 파일 전체 내용 (모든 환경 변수 포함)
#   - SSH_HOST: 배포 서버 호스트 주소 (예: 34.87.184.111)
#   - SSH_PRIVATE_KEY: SSH 개인 키 전체 내용
#
# 선택적 Secrets:
#   - SSH_USER: SSH 사용자명 (기본값: ajk60)
#
# ============================================================================
# 변수 가져오기 방식
# ============================================================================
#
# 1. ENV_FILE Secret:
#    - GitHub Secrets에 .env 파일 전체 내용을 저장
#    - BUILD 단계: ENV_FILE secret → .env 파일 생성 (로컬)
#    - DEPLOY 단계: ENV_FILE secret → .env 파일 생성 → scp로 서버 전송
#
# 2. SSH 관련 Secrets:
#    - SSH_HOST: ${{ secrets.SSH_HOST }}로 직접 사용
#    - SSH_PRIVATE_KEY: webfactory/ssh-agent@v0.9.0 액션에서 사용
#    - SSH_USER: ${{ secrets.SSH_USER || 'ajk60' }} (기본값 포함)
#
# 3. 기타 Secrets:
#    - GITHUB_TOKEN: 자동 제공 (GitHub Container Registry 로그인용)
#
# ============================================================================

name: CI/CD Pipeline

on:
  push:
    branches:
      - feature/ai
      - develop
  pull_request:
    branches:
      - feature/ai
      - develop
  workflow_dispatch:  # 수동 실행 가능

env:
  PYTHON_VERSION: '3.11'
  DOCKER_IMAGE_NAME: dataextraction
  REGISTRY: ghcr.io  # GitHub Container Registry 사용

jobs:
  # 코드 품질 및 테스트
  test:
    name: Test & Lint
    runs-on: ubuntu-latest

    services:
      redis:
        image: redis:7.2-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip packages
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov black flake8 mypy

      - name: Run linter (flake8)
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics || true
        continue-on-error: true

      - name: Check code formatting (black)
        run: |
          black --check . || true
        continue-on-error: true

      - name: Run tests
        env:
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          OPENSEARCH_HOST: localhost
          OPENSEARCH_PORT: 9200
        run: |
          pytest --cov=. --cov-report=xml --cov-report=html || true
        continue-on-error: true

  # Docker 빌드 및 테스트
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push'
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create .env file from ENV_FILE secret
        run: |
          # GitHub Secrets의 ENV_FILE에서 .env 파일 전체 내용 가져오기
          if [ -n "${{ secrets.ENV_FILE }}" ]; then
            echo "${{ secrets.ENV_FILE }}" > .env
            echo ".env 파일 생성 완료 (ENV_FILE secret에서 가져옴)"
          else
            echo "⚠️ ENV_FILE secret이 설정되지 않았습니다. 기본 .env 파일을 생성합니다."
            # 기본값으로 빈 .env 파일 생성 (필요시 수정)
            touch .env
          fi
          # 민감한 정보는 로그에서 자동으로 마스킹됨

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository }}/${{ env.DOCKER_IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Build Docker image (test only)
        if: github.event_name == 'pull_request'
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: ${{ env.DOCKER_IMAGE_NAME }}:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Test Docker image
        run: |
          # Redis 서비스 시작
          docker compose up -d redis_cache
          sleep 5

          # FastAPI 서비스 빌드 및 시작
          docker compose build fastapi_server
          docker compose up -d fastapi_server

          # 컨테이너 로그 확인
          echo "컨테이너 로그 확인 중..."
          docker compose logs fastapi_server | tail -20
          
          # 헬스 체크 (최대 60초 대기, 루트 경로 사용)
          echo "헬스 체크 대기 중..."
          sleep 10  # 초기 대기 시간 증가
          
          for i in {1..12}; do
            # 루트 경로로 헬스 체크 (또는 /docs 경로)
            if curl -f -s http://localhost:8000/ > /dev/null 2>&1 || \
               curl -f -s http://localhost:8000/docs > /dev/null 2>&1; then
              echo "헬스 체크 성공!"
              break
            else
              echo "헬스 체크 실패, 재시도 중... ($i/6)"
              sleep 5
            fi
          done

          # 최종 헬스 체크
          if curl -f -s http://localhost:8000/ > /dev/null 2>&1 || \
             curl -f -s http://localhost:8000/docs > /dev/null 2>&1; then
            echo "✅ 헬스 체크 성공!"
          else
            echo "❌ 헬스 체크 실패"
            echo "컨테이너 로그:"
            docker compose logs fastapi_server
            exit 1
          fi

          # 정리
          docker compose down

  # SSH를 통한 배포
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build
    if: (github.ref == 'refs/heads/feature/ai') && github.event_name == 'push'
    environment:
      name: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Create .env file for deployment
        run: |
          # ENV_FILE secret에서 .env 파일 생성
          echo "${{ secrets.ENV_FILE }}" > .env
          echo ".env 파일 생성 완료 (로컬)"

      - name: Deploy via SSH
        run: |
          SSH_HOST="${{ secrets.SSH_HOST }}"
          SSH_USER="${{ secrets.SSH_USER || 'ajk60' }}"
          
          echo "서버에 연결 중: ${SSH_USER}@${SSH_HOST}"
          
          # .env 파일을 서버로 전송
          scp -o StrictHostKeyChecking=no .env ${SSH_USER}@${SSH_HOST}:~/DataExtraction/.env || \
          scp -o StrictHostKeyChecking=no .env ${SSH_USER}@${SSH_HOST}:/home/${SSH_USER}/DataExtraction/.env || \
          scp -o StrictHostKeyChecking=no .env ${SSH_USER}@${SSH_HOST}:/opt/DataExtraction/.env || {
            echo "⚠️ .env 파일 전송 실패, SSH 세션에서 직접 생성합니다."
          }
          
          ssh -o StrictHostKeyChecking=no ${SSH_USER}@${SSH_HOST} bash -s << 'ENDSSH'
            set -e  # 에러 발생 시 중단
            
            SSH_USER="${{ secrets.SSH_USER || 'ajk60' }}"
            
            echo "=== 디스크 공간 확인 ==="
            df -h
            docker system df || true
            
            echo "=== Docker 정리 ==="
            docker system prune -a -f || true
            docker builder prune -a -f || true
            
            echo "=== 프로젝트 디렉토리로 이동 ==="
            cd ~/DataExtraction || cd /home/${SSH_USER}/DataExtraction || cd /opt/DataExtraction || {
              echo "프로젝트 디렉토리를 찾을 수 없습니다."
              exit 1
            }
            
            echo "=== 최신 코드 pull ==="
            # 브랜치 이름 추출 (refs/heads/feature/ai -> feature/ai)
            BRANCH_NAME="${{ github.ref_name }}"
            # refs/heads/ 접두사 제거 (있는 경우)
            BRANCH_NAME=${BRANCH_NAME#refs/heads/}
            echo "배포할 브랜치: $BRANCH_NAME"
            
            # 원격 저장소 정보 확인
            git remote -v || git remote add origin https://github.com/${{ github.repository }}.git || true
            
            # 모든 원격 브랜치 가져오기
            git fetch origin --prune || true
            
            # feature/ai 브랜치로 체크아웃 (없으면 생성)
            if git show-ref --verify --quiet refs/heads/$BRANCH_NAME; then
              echo "로컬 브랜치 $BRANCH_NAME 존재, 체크아웃..."
              git checkout $BRANCH_NAME || true
            else
              echo "로컬 브랜치 $BRANCH_NAME 없음, 생성 및 체크아웃..."
              git checkout -b $BRANCH_NAME origin/$BRANCH_NAME || {
                echo "⚠️ 원격 브랜치 origin/$BRANCH_NAME를 찾을 수 없습니다."
                exit 1
              }
            fi
            
            # 최신 코드로 업데이트
            git reset --hard origin/$BRANCH_NAME || {
              echo "⚠️ Git reset 실패, pull 시도..."
              git pull origin $BRANCH_NAME || {
                echo "❌ Git pull 실패"
                exit 1
              }
            }
            
            echo "✅ 코드 업데이트 완료"
            echo "현재 브랜치: $(git branch --show-current)"
            echo "최신 커밋:"
            git log -1 --oneline || true
            
            echo "=== .env 파일 확인 ==="
            if [ ! -f .env ]; then
              echo "❌ .env 파일이 없습니다. 배포를 중단합니다."
              exit 1
            fi
            echo "✅ .env 파일 확인 완료"
            
            echo "=== GitHub Container Registry 로그인 ==="
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin || true
            
            echo "=== 최신 Docker 이미지 pull ==="
            IMAGE_TAG="${{ env.REGISTRY }}/${{ github.repository }}/${{ env.DOCKER_IMAGE_NAME }}:latest"
            docker pull ${IMAGE_TAG} || {
              echo "⚠️ 이미지 pull 실패, 로컬 빌드 시도..."
              docker compose build --no-cache || docker build -t ${IMAGE_TAG} .
            }
            
<<<<<<< HEAD
=======
            echo "=== SSL 인증서 생성 (없는 경우) ==="
            if [ ! -f nginx/ssl/nginx-selfsigned.crt ] || [ ! -f nginx/ssl/nginx-selfsigned.key ]; then
              echo "SSL 인증서가 없습니다. 생성 중..."
              mkdir -p nginx/ssl
              # OpenSSL이 설치되어 있는지 확인
              if command -v openssl &> /dev/null; then
                openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                  -keyout nginx/ssl/nginx-selfsigned.key \
                  -out nginx/ssl/nginx-selfsigned.crt \
                  -subj "/C=KR/ST=Seoul/L=Seoul/O=DataExtraction/CN=localhost"
                echo "✅ SSL 인증서 생성 완료"
              else
                echo "⚠️ OpenSSL이 설치되어 있지 않습니다. Docker 컨테이너로 생성 시도..."
                docker run --rm -v $(pwd)/nginx/ssl:/ssl alpine/openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                  -keyout /ssl/nginx-selfsigned.key \
                  -out /ssl/nginx-selfsigned.crt \
                  -subj "/C=KR/ST=Seoul/L=Seoul/O=DataExtraction/CN=localhost" || {
                  echo "❌ SSL 인증서 생성 실패. Nginx는 시작되지 않을 수 있습니다."
                }
              fi
            else
              echo "✅ SSL 인증서 이미 존재"
            fi
            
>>>>>>> 30bed4e1b5046741eeec00de15bff537a5ecb047
            echo "=== Docker Compose로 서비스 시작 ==="
            if [ -f docker-compose.yml ]; then
              # 기존 컨테이너 완전히 중지 및 제거
              docker compose down -v || true
              
              # 이미지 태그 업데이트 (docker-compose.yml에 image 필드가 있는 경우)
              # 또는 로컬 빌드 사용
              
              # 새 이미지로 서비스 강제 재생성 및 시작
              docker compose pull || true
              docker compose build --no-cache || true
              docker compose up -d --force-recreate --build --remove-orphans
              
              # 컨테이너 로그 확인
              echo "컨테이너 로그 확인 중..."
              docker compose logs fastapi_server | tail -20
              
              # 헬스 체크 (최대 60초 대기, 루트 경로 사용)
              echo "헬스 체크 대기 중..."
              sleep 15
              docker compose ps
              
              # 헬스 체크 확인
              for i in {1..12}; do
                # 루트 경로로 헬스 체크 (또는 /docs 경로)
                if curl -f -s http://localhost:8000/ > /dev/null 2>&1 || \
                   curl -f -s http://localhost:8000/docs > /dev/null 2>&1; then
                  echo "헬스 체크 성공!"
                  break
                else
                  echo "헬스 체크 실패, 재시도 중... ($i/12)"
                  # 컨테이너 상태 확인
                  docker compose ps
                  docker compose logs --tail=10 fastapi_server
                  sleep 5
                fi
              done
              
              # 최종 헬스 체크
              if curl -f -s http://localhost:8000/ > /dev/null 2>&1 || \
                 curl -f -s http://localhost:8000/docs > /dev/null 2>&1; then
<<<<<<< HEAD
                echo "✅ 헬스 체크 성공!"
              else
                echo "❌ 헬스 체크 실패"
                echo "컨테이너 로그:"
                docker compose logs fastapi_server
                echo "⚠️ 헬스 체크 실패했지만 배포는 계속 진행합니다."
=======
                echo "✅ HTTP 헬스 체크 성공!"
              else
                echo "❌ HTTP 헬스 체크 실패"
                echo "컨테이너 로그:"
                docker compose logs fastapi_server
                echo "⚠️ HTTP 헬스 체크 실패했지만 배포는 계속 진행합니다."
              fi
              
              # HTTPS 헬스 체크 (Nginx가 실행 중인 경우)
              echo "=== HTTPS 헬스 체크 ==="
              sleep 5
              if curl -k -f -s https://localhost/ > /dev/null 2>&1 || \
                 curl -k -f -s https://localhost/docs > /dev/null 2>&1; then
                echo "✅ HTTPS 헬스 체크 성공!"
              else
                echo "⚠️ HTTPS 헬스 체크 실패 (Nginx가 아직 시작 중일 수 있음)"
                docker compose logs nginx | tail -20 || true
>>>>>>> 30bed4e1b5046741eeec00de15bff537a5ecb047
              fi
            else
              # Docker Compose가 없는 경우 직접 컨테이너 실행
              docker stop ${{ env.DOCKER_IMAGE_NAME }} || true
              docker rm ${{ env.DOCKER_IMAGE_NAME }} || true
              docker run -d --name ${{ env.DOCKER_IMAGE_NAME }} \
                --restart unless-stopped \
                -p 8000:8000 \
                --env-file .env \
                ${{ env.REGISTRY }}/${{ github.repository }}/${{ env.DOCKER_IMAGE_NAME }}:latest
            fi
            
            echo "=== 정리 (사용하지 않는 이미지 제거) ==="
            docker image prune -f || true
            
            echo "=== 최종 디스크 사용량 ==="
            df -h
            docker system df || true
            
            echo "배포 완료!"
          ENDSSH
          
          echo "배포 완료!"